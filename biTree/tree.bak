#include "tree.h"
#include <math.h>
#include <set>
#include <sstream>
#include <iostream>
#include <limits.h>
#include <stack>
#include <list>
using namespace std;
using namespace huaguisoftware;

// 试题二说明：
// 要求设计并实现一个“完全二叉树”，处理加减乘除的计算公式
// 不考虑括号，遇到非数字或者运算符(+-*/)请抛出异常
// 

bool isnum(string& s){
    if( !s.empty() ){
        s.erase(0,s.find_first_not_of(" "));
        s.erase(s.find_last_not_of(" ") + 1);
    }
    stringstream sin(s);
    double t;
    char p;
    if(!(sin >> t))
        return false;
    if(sin >> p)
        return false;
    else
        return true;
}

double stringToDouble(string& str){  
    if( !str.empty() ){
        str.erase(0,str.find_first_not_of(" "));
        str.erase(str.find_last_not_of(" ") + 1);
    }
    istringstream iss(str);  
    double num;  
    iss >> num;  
    return num;      
} 

string visit(const pBiNode& p){
    if(p) 
		return p->data+ " ";
	else
		return "";
}

string preorder(const pBiNode& p){
    string temp;
    if(p)
    {
        temp.append(visit(p));
        temp.append(preorder(p->leftchild));
        temp.append(preorder(p->rightchild));
    }
    return temp;
}

string inorder(const pBiNode& p){
    string temp;
    if(p){
        temp.append(inorder(p->leftchild));
        temp.append(visit(p));
        temp.append(inorder(p->rightchild));
    }
    return temp;
}

string rightfirstorder(const pBiNode& p){
    string temp;
    if(p) {
        temp.append(rightfirstorder(p->rightchild));
        temp.append(visit(p));
        temp.append(rightfirstorder(p->leftchild));
    }
    return temp;
}

string postorder(const pBiNode& p){
    string temp;
    if(p){
        temp.append(postorder(p->leftchild));
        temp.append(postorder(p->rightchild));
        temp.append(visit(p));
    }
    return temp;
}

tree::tree(string input){
    mRoot = 0;        			// root init to NULL
    mSrcinput.clear();  		// all node data clear
    if(input.size( )== 0) return; // empty tree
    string temp;    
    for(int i=0 ; i< input.size() ; ++i){
        if(input[i] >= '0' && input[i] <= '9'){
            temp.append(1,input[i]);
        }
        else if (input[i] == '.'){
            temp.append(1,input[i]);
        }
        else if (OPERATOR.find(input[i]) != OPERATOR.end()){
            if (!temp.empty()){
                mSrcinput.push_back(temp);
                string x;
                x.append(1,input[i]);
                mSrcinput.push_back(x);
                temp.clear();
            }
        }
        else if (input[i] == '(' || input[i] == ')'){
            //ignore the '(' and ')'
            cout << "The  '" << input[i] << "' has been ignored" <<endl; 
            continue;
        }
        else{
            throw invalid_argument(string(" Exception::error input char : ").append(1,input[i]));
        }
    }

    if(!temp.empty()) mSrcinput.push_back(temp);	// last element push back
    if(mSrcinput.size() >0) make_tree(0,mSrcinput.size());  // make tree
        
}

tree::~tree(){}

pBiNode tree::make_tree(int _begin,int _end){
    int height = 0;
    double rootPos = -1;
    pBiNode newNode = 0;
    
    if( _end - _begin > 0){
        height = log( _end  - _begin )/log(2) + 1;
        newNode = new BiNode();
		// this tree root node init
        if (_begin == 0 && _end == mSrcinput.size())
            mRoot=newNode;
        
		if (height == 1) {	// just one element,then make node and return
            rootPos = 1;
            newNode->data=mSrcinput[_begin];
            newNode->leftchild=0;
            newNode->rightchild=0;
            return newNode;
        }

        // calculate current root node,and assign node data
        rootPos = pow(2.0 , (double)(height - 1));
        newNode->data=mSrcinput[(int)rootPos + _begin - 1];

        // make left child tree
        pBiNode rt=make_tree( _begin,( _begin + (int)rootPos)-1);
        newNode->leftchild = rt;
        
		// make right child tree
        rt = make_tree( _begin+(int)rootPos , _end );        
        newNode->rightchild = rt;
    }
    return newNode;
}

// 左遍历
// 左 根 右 顺序
string tree::traverse_left_first(){

    return  inorder(mRoot); 
	// 注释上面的代码并在此实现题目的要求。
}

// 右遍历
// 右 根 左 方式
string tree::traverse_right_first(){
    return rightfirstorder(mRoot);
	// 注释上面的代码并在此实现题目的要求。
}

// 深度优先遍历
string tree::traverse_depth_first(){
    
    stack<pBiNode> nodeStack;
    nodeStack.push(mRoot);
    string temp;
    while (!nodeStack.empty()){
        pBiNode node = nodeStack.top();
        temp.append(node->data + " ");
        nodeStack.pop();
        if (node->rightchild){
           nodeStack.push(node->rightchild);
        }
        if (node->leftchild){
           nodeStack.push(node->leftchild);
        }
    }

    return temp;
	// 注释上面的代码并在此实现题目的要求。
}

double tree::calculate(const string& op,const double& left,const double& right){
    double d=LONG_MIN; 
    if (left!=LONG_MIN && right!=LONG_MIN){
        if(op == "+") d = left + right ;
        else if(op == "-") d = left - right ;
        else if(op == "*") d = left * right ;
        else if(op == "/"){ 
                if (right!=0) d=left/right;
                else throw std::overflow_error(string("Exception::the divisor is 0"));
            }
        else
            throw std::invalid_argument("Exception :: " + op + " is invalid calculate");
     }           
     return d;           
    
}
bool tree::checkPriority(const string& op)
{
    if (op == "+" ||  op == "-")
        return false;
    else if (op=="*" ||  op == "/")
        return true;
    else
        throw std::invalid_argument("Exception:: " + op + " is invalid");
        
}

// 计算结果
//double tree::calc(){
//	return calc_tree(mRoot); 
	//	return -1;
	// 注释上面的代码并在此实现题目的要求。
//}
double tree::calc()
{
    // 存操作数 模拟栈功能 不过这个可以两边进行操作
    list<double> st_num;
    //存操作类型
    list<string> st_op;
    double d;
    //这里完成* / 操作 ，用list 尾部进行操作
    for (int i=0;i<mSrcinput.size();++i){
        if(isnum(mSrcinput[i]))
            st_num.push_back(stringToDouble(mSrcinput[i]));
        else if ( checkPriority(mSrcinput[i])) { // true * /
            double right = stringToDouble(mSrcinput[i+1]);
            double dt = calculate(mSrcinput[i],st_num.back(),right);
            st_num.pop_back();
            st_num.push_back(dt);
            ++i;        // i+1 has calculate the result ,so jump one step
        }
        else
            st_op.push_back(mSrcinput[i]);
    }
    if(st_num.size()==1 && st_op.size()==0){
        d = st_num.front();
        st_num.pop_front();
        return d;

    }
    //到这里，只剩加减操作了,这时候要从 list 头部开始操作
    double temp;
    while(!st_num.empty() && !st_op.empty()){
        double left = st_num.front();
        st_num.pop_front();
        double right = st_num.front();
        st_num.pop_front();

        string op=st_op.front();
        st_op.pop_front();

        temp = calculate(op,left,right);
        st_num.push_front(temp);
    }
    d = st_num.front();
    st_num.pop_front();
    return d;
}
